% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ansi-sgr.R
\name{dot-api-sgr}
\alias{dot-api-sgr}
\alias{.sgrCreateSequence}
\alias{.sgrSimplifySequence}
\alias{.sgrGetParameters}
\alias{.sgrPushParameters}
\alias{.sgrPopParameters}
\alias{.sgrIsValidStrictSequence}
\alias{.sgrIsValidSequence}
\title{Low-level API to manipulate ANSI sequences of SGR parameters}
\usage{
.sgrCreateSequence(...)

.sgrSimplifySequence(string = character(1L))

.sgrGetParameters(string = character(1L))

.sgrPushParameters(string = character(1L), ...)

.sgrPopParameters(string = character(1L), ...)

.sgrIsValidStrictSequence(string = character(1L))

.sgrIsValidSequence(string = character(1L))
}
\arguments{
\item{...}{\verb{[integer() | list()]}

Any number of \R structures containing integer values (possibly)
representing SGR parameters. No coercion is done.}

\item{string}{\verb{[character(1)]}

An ANSI sequence of SGR parameters.}
}
\value{
This depends on the function used.
\itemize{
\item \code{\link[=.sgrCreateSequence]{.sgrCreateSequence()}}, \code{\link[=.sgrSimplifySequence]{.sgrSimplifySequence()}}, \code{\link[=.sgrPushParameters]{.sgrPushParameters()}},
and \code{\link[=.sgrPopParameters]{.sgrPopParameters()}} return a \code{character(1)} representing a strictly
valid ANSI sequence of SGR parameters.
\item \code{\link[=.sgrGetParameters]{.sgrGetParameters()}} returns an \code{integer()} holding valid SGR parameters
extracted from an ANSI sequence. This sequence needs not to be either valid
or strict.
\item \code{\link[=.sgrIsValidStrictSequence]{.sgrIsValidStrictSequence()}} and \code{\link[=.sgrIsValidSequence]{.sgrIsValidSequence()}} return a
\code{logical(1)}. See section Details for the difference between strict
and non-strict sequences.
}
}
\description{
Create sequences of SGR parameters, assess their validity, and
manipulate their components.

These functions are collectively considered to be a CRUD (\emph{Create}, \emph{Read},
\emph{Update}, \emph{Delete}) interface to ANSI sequences holding SGR parameters.
They are meant to be used as building blocks of higher-order functions.
}
\details{
A \emph{valid} ANSI sequence can be strict or non-strict.
\subsection{Strict sequences}{

A string is a \emph{strictly valid} ANSI sequence if these threee criteria
are met.
\enumerate{
\item It begins by the CSI (\emph{Control Sequence Introducer}) string \verb{\\033[},
where \verb{\\033} is the octal representation of the ASCII \code{ESC} character.
\item It ends with a single \code{m} character.
\item It encloses an arbitrary number of unquoted SGR parameters (integer
values) all followed by a single \verb{;} character (except for the last
one who is followed by the terminating character \code{m}).
}

Examples of strictly valid sequences are strings like \verb{\\033[0m}
and \verb{\\033[1;2;33m}.
}

\subsection{Non-strict sequences}{

A string is a \emph{non-strictly valid} ANSI sequence if it is composed of one
or multiple strictly valid sequences concatenated together. Examples of
such sequences are strings like \verb{\\033[1m\\033[2;3m} and
\verb{\\033[0m\\033[5;66m}.
}
}
\note{
All these functions perform no input validation at runtime. Failing
to pass valid parameters leads to undefined behavior. Because of that,
they should always be wrapped into higher-order functions.
}
\keyword{internal}
